# generated by datamodel-codegen:
#   filename:  stream_info_response.json
#   timestamp: 2021-07-18T15:27:44+00:00

from __future__ import annotations

from enum import Enum
from typing import List, Optional, Union

from pydantic import BaseModel, Field, confloat, conint, constr


class IoNatsJetstreamApiV1StreamInfoResponse1(BaseModel):
    type: str


class Retention(Enum):
    limits = "limits"
    interest = "interest"
    workqueue = "workqueue"


class Storage(Enum):
    file = "file"
    memory = "memory"


class Discard(Enum):
    old = "old"
    new = "new"


class Placement(BaseModel):
    cluster: constr(min_length=1) = Field(
        ..., description="The desired cluster name to place the stream"
    )
    tags: Optional[List[str]] = Field(
        None, description="Tags required on servers hosting this stream"
    )


class External(BaseModel):
    api: str = Field(
        ...,
        description="The subject prefix that imports the other account/domain $JS.API.CONSUMER.> subjects",
    )
    deliver: Optional[str] = Field(
        None, description="The delivery subject to use for the push consumer"
    )


class Mirror(BaseModel):
    name: constr(regex=r"^[^.*>]+$", min_length=1) = Field(
        ..., description="Stream name"
    )
    opt_start_seq: Optional[conint(ge=0)] = Field(
        None, description="Sequence to start replicating from"
    )
    opt_start_time: Optional[str] = Field(
        None, description="Time stamp to start replicating from"
    )
    filter_subject: Optional[str] = Field(
        None, description="Replicate only a subset of messages based on filter"
    )
    external: Optional[External] = Field(
        None,
        description="Configuration referencing a stream source in another account or JetStream domain",
    )


class External1(BaseModel):
    api: str = Field(
        ...,
        description="The subject prefix that imports the other account/domain $JS.API.CONSUMER.> subjects",
    )
    deliver: Optional[str] = Field(
        None, description="The delivery subject to use for the push consumer"
    )


class Source(BaseModel):
    name: constr(regex=r"^[^.*>]+$", min_length=1) = Field(
        ..., description="Stream name"
    )
    opt_start_seq: Optional[conint(ge=0)] = Field(
        None, description="Sequence to start replicating from"
    )
    opt_start_time: Optional[str] = Field(
        None, description="Time stamp to start replicating from"
    )
    filter_subject: Optional[str] = Field(
        None, description="Replicate only a subset of messages based on filter"
    )
    external: Optional[External1] = Field(
        None,
        description="Configuration referencing a stream source in another account or JetStream domain",
    )


class Config(BaseModel):
    name: Optional[constr(regex=r"^[^.*>]*$", min_length=0)] = Field(
        None, description="A unique name for the Stream, empty for Stream Templates."
    )
    subjects: Optional[List[str]] = Field(
        None,
        description="A list of subjects to consume, supports wildcards. Must be empty when a mirror is configured. May be empty when sources are configured.",
        min_length=0,
    )
    retention: Retention = Field(
        ...,
        description="How messages are retained in the Stream, once this is exceeded old messages are removed.",
    )
    max_consumers: conint(ge=-1) = Field(
        ...,
        description="How many Consumers can be defined for a given Stream. -1 for unlimited.",
    )
    max_msgs: conint(ge=-1) = Field(
        ...,
        description="How many messages may be in a Stream, oldest messages will be removed if the Stream exceeds this size. -1 for unlimited.",
    )
    max_msgs_per_subject: Optional[conint(ge=-1)] = Field(
        -1,
        description="For wildcard streams ensure that for every unique subject this many messages are kept - a per subject retention limit",
    )
    max_bytes: conint(ge=-1) = Field(
        ...,
        description="How big the Stream may be, when the combined stream size exceeds this old messages are removed. -1 for unlimited.",
    )
    max_age: conint(ge=0) = Field(
        ...,
        description="Maximum age of any message in the stream, expressed in nanoseconds. 0 for unlimited.",
    )
    max_msg_size: Optional[conint(ge=-1)] = Field(
        -1,
        description="The largest message that will be accepted by the Stream. -1 for unlimited.",
    )
    storage: Storage = Field(
        ..., description="The storage backend to use for the Stream."
    )
    num_replicas: conint(ge=1, le=5) = Field(
        ..., description="How many replicas to keep for each message."
    )
    no_ack: Optional[bool] = Field(
        False,
        description="Disables acknowledging messages that are received by the Stream.",
    )
    template_owner: Optional[str] = Field(
        None,
        description="When the Stream is managed by a Stream Template this identifies the template that manages the Stream.",
    )
    discard: Optional[Discard] = Field(
        "old",
        description="When a Stream reach it's limits either old messages are deleted or new ones are denied",
    )
    duplicate_window: Optional[conint(ge=0)] = Field(
        0,
        description="The time window to track duplicate messages for, expressed in nanoseconds. 0 for default",
    )
    placement: Optional[Placement] = Field(
        None,
        description="Placement directives to consider when placing replicas of this stream, random placement when unset",
    )
    mirror: Optional[Mirror] = Field(
        None,
        description="Maintains a 1:1 mirror of another stream with name matching this property.  When a mirror is configured subjects and sources must be empty.",
    )
    sources: Optional[List[Source]] = Field(
        None, description="List of Stream names to replicate into this Stream"
    )


class DeletedItem(BaseModel):
    __root__: conint(ge=0)


class Lost(BaseModel):
    msgs: Optional[List[conint(ge=0)]] = Field(
        None, description="The messages that were lost"
    )
    bytes: Optional[int] = Field(None, description="The number of bytes that were lost")


class State(BaseModel):
    messages: conint(ge=0) = Field(
        ..., description="Number of messages stored in the Stream"
    )
    bytes: conint(ge=0) = Field(
        ..., description="Combined size of all messages in the Stream"
    )
    first_seq: conint(ge=0) = Field(
        ..., description="Sequence number of the first message in the Stream"
    )
    first_ts: Optional[str] = Field(
        None, description="The timestamp of the first message in the Stream"
    )
    last_seq: conint(ge=0) = Field(
        ..., description="Sequence number of the last message in the Stream"
    )
    last_ts: Optional[str] = Field(
        None, description="The timestamp of the last message in the Stream"
    )
    deleted: Optional[List[DeletedItem]] = Field(
        None,
        description="IDs of messages that were deleted using the Message Delete API or Interest based streams removing messages out of order",
    )
    num_deleted: Optional[conint(ge=0)] = Field(
        None, description="The number of deleted messages"
    )
    lost: Optional[Lost] = Field(
        None, description="Records messages that were damaged and unrecoverable"
    )
    consumer_count: conint(ge=0) = Field(
        ..., description="Number of Consumers attached to the Stream"
    )


class Replica(BaseModel):
    name: str = Field(..., description="The server name of the peer")
    current: bool = Field(
        ..., description="Indicates if the server is up to date and synchronised"
    )
    active: float = Field(..., description="Nanoseconds since this peer was last seen")
    offline: Optional[bool] = Field(
        False, description="Indicates the node is considered offline by the group"
    )
    lag: Optional[conint(ge=0)] = Field(
        None,
        description="How many uncommitted operations this peer is behind the leader",
    )


class Cluster(BaseModel):
    name: Optional[str] = Field(None, description="The cluster name")
    leader: Optional[str] = Field(
        None, description="The server name of the RAFT leader"
    )
    replicas: Optional[List[Replica]] = Field(
        None, description="The members of the RAFT cluster"
    )


class External2(BaseModel):
    api: str = Field(
        ...,
        description="The subject prefix that imports the other account/domain $JS.API.CONSUMER.> subjects",
    )
    deliver: Optional[str] = Field(
        None, description="The delivery subject to use for the push consumer"
    )


class Error(BaseModel):
    code: conint(ge=300, le=699) = Field(
        ..., description="HTTP like error code in the 300 to 500 range"
    )
    description: Optional[str] = Field(
        None, description="A human friendly description of the error"
    )


class Mirror1(BaseModel):
    name: str = Field(..., description="The name of the Stream being replicated")
    lag: confloat(ge=0.0) = Field(
        ..., description="How many messages behind the mirror operation is"
    )
    active: confloat(ge=0.0) = Field(
        ..., description="When last the mirror had activity, in nanoseconds"
    )
    external: Optional[External2] = Field(
        None,
        description="Configuration referencing a stream source in another account or JetStream domain",
    )
    error: Optional[Error] = None


class External3(BaseModel):
    api: str = Field(
        ...,
        description="The subject prefix that imports the other account/domain $JS.API.CONSUMER.> subjects",
    )
    deliver: Optional[str] = Field(
        None, description="The delivery subject to use for the push consumer"
    )


class Error1(BaseModel):
    code: conint(ge=300, le=699) = Field(
        ..., description="HTTP like error code in the 300 to 500 range"
    )
    description: Optional[str] = Field(
        None, description="A human friendly description of the error"
    )


class Source1(BaseModel):
    name: str = Field(..., description="The name of the Stream being replicated")
    lag: confloat(ge=0.0) = Field(
        ..., description="How many messages behind the mirror operation is"
    )
    active: confloat(ge=0.0) = Field(
        ..., description="When last the mirror had activity, in nanoseconds"
    )
    external: Optional[External3] = Field(
        None,
        description="Configuration referencing a stream source in another account or JetStream domain",
    )
    error: Optional[Error1] = None


class IoNatsJetstreamApiV1StreamInfoResponseItem(BaseModel):
    config: Config = Field(..., description="The active configuration for the Stream")
    state: State = Field(
        ..., description="Detail about the current State of the Stream"
    )
    created: str = Field(..., description="Timestamp when the stream was created")
    cluster: Optional[Cluster] = None
    mirror: Optional[Mirror1] = Field(
        None, description="Information about an upstream stream source in a mirror"
    )
    sources: Optional[List[Source1]] = Field(
        None, description="Streams being sourced into this Stream"
    )


class Error2(BaseModel):
    code: conint(ge=300, le=699) = Field(
        ..., description="HTTP like error code in the 300 to 500 range"
    )
    description: Optional[str] = Field(
        None, description="A human friendly description of the error"
    )


class IoNatsJetstreamApiV1StreamInfoResponseItem1(BaseModel):
    error: Error2


class IoNatsJetstreamApiV1StreamInfoResponse(BaseModel):
    __root__: Union[
        IoNatsJetstreamApiV1StreamInfoResponseItem,
        IoNatsJetstreamApiV1StreamInfoResponseItem1,
        IoNatsJetstreamApiV1StreamInfoResponse1,
    ] = Field(
        ...,
        description="A response from the JetStream $JS.API.STREAM.INFO API",
        title="io.nats.jetstream.api.v1.stream_info_response",
    )
