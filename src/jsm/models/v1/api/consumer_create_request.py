# generated by datamodel-codegen:
#   filename:  consumer_create_request.json
#   timestamp: 2021-07-18T15:27:41+00:00

from __future__ import annotations

from enum import Enum
from typing import Optional, Union

from pydantic import BaseModel, Field, conint, constr


class AckPolicy(Enum):
    none = "none"
    all = "all"
    explicit = "explicit"


class ReplayPolicy(Enum):
    instant = "instant"
    original = "original"


class Config(BaseModel):
    durable_name: Optional[constr(regex=r"^[^.*>]+$", min_length=1)] = Field(
        None, description="A unique name for a durable consumer"
    )
    deliver_subject: Optional[constr(min_length=1)] = None
    deliver_policy: Optional[Union[str, int]] = None
    ack_policy: AckPolicy
    ack_wait: Optional[conint(ge=1)] = Field(
        None,
        description="How long (in nanoseconds) to allow messages to remain un-acknowledged before attempting redelivery",
    )
    max_deliver: Optional[int] = Field(
        None,
        description="The number of times a message will be redelivered to consumers if not acknowledged in time",
    )
    filter_subject: Optional[str] = None
    replay_policy: ReplayPolicy
    sample_freq: Optional[str] = None
    rate_limit_bps: Optional[conint(ge=0)] = Field(
        None,
        description="The rate at which messages will be delivered to clients, expressed in bit per second",
    )
    max_ack_pending: Optional[int] = Field(
        None,
        description="The maximum number of messages without acknowledgement that can be outstanding, once this limit is reached message delivery will be suspended",
    )
    idle_heartbeat: Optional[conint(ge=0)] = Field(
        None,
        description="If the Consumer is idle for more than this many nano seconds a empty message with Status header 100 will be sent indicating the consumer is still alive",
    )
    flow_control: Optional[bool] = Field(
        None,
        description="For push consumers this will regularly send an empty mess with Status header 100 and a reply subject, consumers must reply to these messages to control the rate of message delivery",
    )
    max_waiting: Optional[conint(ge=0)] = Field(
        512,
        description="The number of pulls that can be outstanding on a pull consumer, pulls received after this is reached are ignored",
    )


class IoNatsJetstreamApiV1ConsumerCreateRequest(BaseModel):
    stream_name: str = Field(
        ..., description="The name of the stream to create the consumer in"
    )
    config: Config = Field(..., description="The consumer configuration")
